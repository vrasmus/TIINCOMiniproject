As a starting point for the analysis, the following 3 polynomial sets of convolutional codes were given. The first subscript represents the code number (further referenced in the report) and the second is the index of the generator polynomial associated with the code.

\begin{align*}
\begin{matrix}
Code 1&Code 2&Code 3\\
g_{1,1}(x) = 1 + x + x^2 + x^3 + x^6&g_{2,1}(x) = 1 + x^2 + x^3&g_{3,1}(x)=1 + x^2\\
g_{1,2}(x) = 1 + x^2 + x^3 + x^5 + x^6&g_{2,2}(x)=1 + x + x^3&g_{3,2} = 1+x+x^2\\
&g_{2,3}(x) = 1+x+x^2+x^3&g_{2,3}(x)=1+x+x^2\\
&&g_{3,4}(x) = 1+x+x^2
\end{matrix}
\end{align*}

We started our investigation by comparing how these given codes can handle random and burst errors on the channels. For this purpose, we designed 2 Matlab scripts that would allow us to simulate the transmission of a message over the given types of channels.

In both scripts, it is possible to adjust the input message length and the number of times the simulation should run. Increasing the number of simulation iterations will generates smoother lines of the figures, this reducing the stochastic effects on the results. For our simulations, we iterated the simulation 25 times, with different input messages.

A third file (\verb@trellisGenerator.m@), defining different convolutional code generator polynomials was required in order to easily change the code polynomials used to coding and decoding.

The scripts are summarized as follows:

\subsection{Random errors generation}

The file \verb@randomErrors.m@ presents the method of simulation of random errors on a BSC. In the script, it is possible to modify the following simulation parameters:

\begin{itemize}
   \item \verb@maxCER@ - maximum channel error rate. A value of 0.1 would mean that the channel can, at maximum, change 10\% of the transmitted bits.
   \item \verb@CERLevels@ - the number of different channel error levels for the simulation. This value determines the granularity of the increase steps for the error rate.  
\end{itemize}

For the specified number of iterations, the script generates a message of the given length. The message is then encoded using the code definitions from \verb@trellisGenerator.m@ file and for each of the codes, the encoded data is altered using the different levels of error probability. The alteration of bits at random positions in the message simulates the channel noise. For each of the error levels, the data is then decoded and compared to the transmitted version, calculating the Bit Error Rate (BER).

\subsection{Burst errors generation}

The file \verb@burstErrors.m@ presents the method of simulation of burst errors on a transmission channel. In the script, it is possible to modify the following simulation parameters:

\begin{itemize}
   \item \verb@BurstLevels@ - the number of different error burst lengths that are introduced on the channel. 
   \item \verb@nBursts@ - the total number of error bursts to be introduced on the channel.
   \item \verb@burstSep@ - the number of unaffected bits between error bursts.
\end{itemize}

Just as it happens in the case of the BSC, for the specified number of iterations, the script generates a message of the given length. The message is then encoded using the code definitions from \verb@trellisGenerator.m@ file and for each of the codes, the encoded data is altered using the different levels of burst error. The burst error represents a channel being temporarily affected by interference. For each level of burst, the data is then decoded and compared to the transmitted version, calculating the Burst Error (BE).
\\[8pt]

The results for the given codes are presented in section \ref{sec:givenCodesSection}. Even though the results, show as expected, a negative relation between the code rate and constraint length on one side and error rates on the other, we considered that simulations where we are varying only one of the factors are necessary. This approach allows us not only to confirm that both the factors influence the error correction capabilities of the code, but also to assess their sensibility.

In order to achieve the above mentioned, we needed to come up with 6 new set of codes namely Code 4 to 9. Their generator polynomials are presented below.

\begin{align*}
\begin{matrix}
Code 4&Code 5&Code 6\\
g_{4,1}(x) = 1 + x^2 + x^3&g_{5,1}(x) = 1 + x^2&g_{6,1}(x)=1 + x + x^2 + x^3 + x^6\\
g_{4,2}(x) = 1+x+x^2+x^3&g_{5,2}(x) = 1+x+x^2&g_{6,2}(x)=1 + x^2 + x^3 + x^5 + x^6\\
&&g_{6,3}(x)=1 + x + x^2 + x^3 + x^4 + x^5 + x^6\\
\end{matrix}\\
\begin{matrix}
Code 7&Code 8&Code 9\\
g_{7,1}(x) = 1 + x^2&g_{8,1}(x) = 1 + x + x^2 + x^3 + x^6&g_{9,1}(x)=1 + x^2 + x^3\\
g_{7,2}(x) = 1+x+x^2&g_{8,2}(x) = 1 + x + x^3 + x^4 + x^6&g_{9,2}(x)=1 + x + x^3\\
g_{7,3}(x) = 1+x+x^2&g_{8,3}(x) = 1 + x^2 + x^3 + x^5 + x^6&g_{9,3}(x)=1+x+x^2+x^3\\
&g_{8,4}(x) = 1 + x + x^2 + x^3 + x^4 + x^5 + x^6&g_{9,4}(x)=1+x+x^2+x^3\\
\end{matrix}
\end{align*}

Using the above mentioned codes, we were able to group them by code rate and by constraint length, as follows:

\begin{table}[h]
\centering
\caption{Grouping of codes based on code rate}
\begin{tabular}{ll}
\hline
Code rate &  Codes \\ \hline
1/2 & Code 1, Code 4, Code 5 \\
1/3 & Code 2, Code 6, Code 7 \\
1/4 & Code 3, Code 8, Code 9 \\
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Grouping of codes based on constraint length}
\begin{tabular}{ll}
\hline
Constraint length &  Codes \\ \hline
3 & Code 3, Code 5, Code 7 \\
4 & Code 2, Code 4, Code 9 \\
7 & Code 1, Code 6, Code 8 \\
\end{tabular}
\end{table}

The results obtained when having the constant code rate of 1/2 and variable constraint length are presented in section \ref{sec:constantCodeRateSection}. Similarly, the results obtained by having a constant constraint length of 4 and variable code lengths are presented in section \ref{sec:constantContraintLengthSection}.

 